
\chapter{Analisi}

Lo scopo di questo capitolo è quello di fornire un'analisi del sistema da proporre. Verrà specificato il contesto nel quale l'artefatto dovrà operare, mettendo in evidenzia l'insieme dei requisiti che dovranno risultare soddisfatti. 
%Per la struttura di questo capitolo verranno utilizzate le specifiche suggerite in \cite{ieee830-1998} come riferimenti.

\section{Scopo del sistema}

Il progetto \emph{MyCLIPS} si prefigge lo scopo di sviluppare un software di tipo \emph{Expert System Environment}, mediante la realizzazione di un ambiente multi-paradigmatico che unisca al classico modello dichiarativo basato su regole, meccanismi di  supporto alla programmazione procedurale.


% e basata su regole, un regime di controllo di tipo \emph{forward chaining} e un'implementazione dell'algoritmo RETE per le operazione di \emph{pattern-matching}.
Affiancato al sistema principale, verrà inoltre progettato un modulo aggiuntivo che consenta la distribuzione dei servizi offerti dal software principale tramite un modello d'architettura \emph{client-server}.

L'artefatto derivante dal progetto, inteso come unione del software principale e del modulo server aggiuntivo, non sarà un prodotto con fini commerciali, ma piuttosto uno strumento con finalità didattiche, di supporto alla ricerca nell'ambito degli \emph{environment per sistemi esperti} e all'integrazione degli stessi con tecnologie orientate al Web.

Nel campo degli \emph{environment}, il software CLIPS rappresenta un punto di riferimento sia nell'ambito dell'efficienza, che del numero di funzionalità offerte. La gratuità e la facile reperibilità del sistema ha garantito una larga adozione in ambito accademico. Il confronto fra il sistema proposto nell'ambito di questo progetto e il software CLIPS rappresenta una metrica per la valutazione del prototipo stesso. Un buon grado di compatibilità fra i due sistemi consentirebbe l'accesso ad un grande bacino di artefatti già prodotti per il sistema CLIPS.

%%%%% ATTIVARE PER COMPILAZIONE RAPPORTO-TECNICO %%%%%
% Include:
% 	- Sezione: Definizioni, acronimi, abbreviazioni
%\include{Rapp-tecnico/glossario}


%%%%% ATTIVARE PER COMPILAZIONE RAPPORTO-TECNICO %%%%%
% Include:
% 	- Sezione: Riferimenti
%\include{Rapp-tecnico/riferimenti}

\section{Capacità}

Il tipo di software che il progetto MyCLIPS punta a realizzare è un \emph{environment} multi-paradigmatico per sistemi esperti. In quanto tale deve offrire strumenti per la realizzazione di sistemi esperti, associando all'uso delle regole di produzione come metodo di rappresentazione della conoscenza, la possibilità di specifica di strutture di controllo tramite un paradigma procedurale.


Si riassumono schematicamente le funzionalità principali richieste al sistema, offrendo anche un riferimento al paragrafo nel quale la capacità viene approfondita e analizzata nel dettaglio:

\begin{enumerate}
	\item l'uso di un linguaggio di specifica che consenta:
		\begin{enumerate}
			\item la definizione di regole di produzione (\ref{par:linguaggio-regole})
			\item l'utilizzo di un paradigma procedurale (\ref{par:linguaggio-funzioni})
			\item la specifica di funzioni utente (\ref{par:linguaggio-funzioni})
			\item la specifica di moduli (\ref{par:linguaggio-moduli})
			\item definizione di template di fatti (\ref{par:linguaggio-template})
			\item la specifica della conoscenza fattuale tramite:
				\begin{enumerate}
					\item fatti in notazione Ordered-Fact (\ref{par:linguaggio-fatti})
					\item fatti in notazione Template-Fact (\ref{par:linguaggio-fatti})
				\end{enumerate}
		\end{enumerate}
	\item la possibilità di aggiungere strategie di risoluzione dei conflitti (\ref{par:strategie-crs})
	\item la possibilità di integrare nuove funzioni di sistema (\ref{par:motore-inferenziale})
	\item compatibilità con i sistemi sviluppati per CLIPS:
		\begin{enumerate}
			\item compatibilità del linguaggio di specifica (\ref{par:linguaggio})
			\item compatibilità delle strategie di risoluzione dei conflitti (\ref{par:strategie-crs})
			\item compatibilità con un \emph{sub-set} delle funzioni di sistema
		\end{enumerate}
	\item l'utilizzo dell'algoritmo RETE per le operazioni di \emph{Pattern-Matching}~(\ref{par:algoritmo-rete})
	\item la possibilità di accedere alle funzionalità del sistema tramite un terminale~(\ref{par:terminale})
	\item la distribuzione delle funzionalità del software tramite un modulo server~(\ref{par:server})
\end{enumerate}


\subsection{Linguaggio di specifica}\label{par:linguaggio}

La compatibilità fra l'\emph{environment} prodotto e il sistema CLIPS rappresenta una delle capacità desiderate. Per realizzarla è necessario consentire l'utilizzo degli artefatti precedentemente prodotti utilizzando il linguaggio di specifica fornito da CLIPS. La restrizione delle capacità richieste alla sola fornitura delle meccaniche di definizione delle regole di produzione e delle strutture di controllo procedurali, consente di restringere l'insieme dei costrutti che è necessario definire escludendo i formalismi di specifica relativi al paradigma di sviluppo orientato agli oggetti concentrati nel sotto-sistema COOL di CLIPS.

%Fra le capacità del sistema è richiesta la fornitura di un linguaggio di specifica che permetta l'utilizzo di sistemi esperti realizzati per il software CLIPS. Il livello di compatibilità previsto richiede di fornire all'utente i costrutti di base utilizzati da CLIPS per la definizione di regole, della conoscenza fattuale (in formato \emph{Ordered-Fact} e \emph{Template-Fact}), dei moduli, delle funzioni utente e delle variabili globali.

Il linguaggio utilizzato deve risultare compatibile sia a livello semantico che a livello sintattico con quello fornito da CLIPS, offrendo in questo modo il massimo livello di portabilità degli artefatti.

\subsubsection{Moduli}\label{par:linguaggio-moduli}
Il formalismo previsto da CLIPS e che dovrà essere supportato dal software prodotto, consente la definizione di moduli attraverso l'utilizzo del costrutto \emph{defmodule}.
Il modulo è un'unità di programma che racchiude e organizza la definizione di ulteriori costrutti. Lo scambio delle definizioni fra moduli differenti è previsto attraverso un protocollo di \emph{import/export}.

\begin{program}
\verbatimtabinput[3]{Capitoli/capitolo-2/bnf/defmodule.txt}
\caption{Specifica \emph{BNF} del costrutto \emph{defmodule}}
\end{program}

La sintassi prevede di associare un nome univoco ad ogni modulo, oltre alla possibilità di specificare un elenco di costrutti da rendere disponibili all'esterno del modulo stesso (tramite l'attributo \emph{export}), oppure un elenco di definizioni da importare da un modulo precedentemente creato (tramite l'attributo \emph{import}).


\subsubsection{Funzioni utente}\label{par:linguaggio-funzioni}
All'utente, in maniera alternativa all'integrazione di funzioni scritte in linguaggio nativo, deve essere offerta la possibilità di aggiungere funzioni personalizzate all'interno del sistema utilizzando il costrutto \emph{deffunction} (Codice~\ref{code:deffunction}). La definizione di funzioni consente di specificare strutture di controllo procedurali che eseguano sequenze di operazioni guidate dai parametri di chiamata.

\begin{program}
\verbatimtabinput[3]{Capitoli/capitolo-2/bnf/deffunction.txt}
\caption{Specifica \emph{BNF} del costrutto \emph{deffunction}}\label{code:deffunction}
\end{program}


Le funzioni cosi integrate potranno essere utilizzate nelle stesse modalità previste dalle altre funzioni di sistema, con l'eccezione relativa ai vincoli di visibilità fra moduli.

\begin{program}
\begin{verbatimtab}

(defmodule A
	(export deffunction Funzione_Di_Prova))
	
(deffunction A::Funzione_Di_Prova () )

(defmodule B
	(import A deffunction Funzione_Di_Prova))
\end{verbatimtab}
\caption{Esempio di scambio di una definizione fra moduli}\label{code:deffunction-import}
\end{program}

Le definizioni di funzioni devono essere esportate dal modulo in cui sono definite e successivamente importate da quello che intende utilizzarle (Codice~\ref{code:deffunction-import}).

\subsubsection{Regole}\label{par:linguaggio-regole}
La specifica di regole deve essere resa disponibile tramite l'utilizzo del costrutto \emph{defrule}~(Codice~\ref{code:defrule}).

\begin{program}
\verbatimtabinput[3]{Capitoli/capitolo-2/bnf/defrule.txt}
\caption{Specifica \emph{BNF} del costrutto \emph{defrule}}\label{code:defrule}
\end{program}

La porzione \emph{LHS} e \emph{RHS} della regola sono separati dal simbolo $=>$. I \emph{pattern} della \emph{LHS} sono definiti con riferimento ai formalismi utilizzati per la specifica di \emph{Ordered-Fact} e \emph{Template-Fact}. Le variabili vengono specificate attraverso l'uso di \emph{wildcard}, identificate dalla presenza del simbolo ''?'' come primo carattere. I \emph{pattern} possono essere ulteriormente specificati tramite l'utilizzo di connettivi logici come \emph{not}, \emph{or} e \emph{and}, oppure espressioni logiche come \emph{exists} o \emph{test}.
La porzione \emph{RHS} contiene chiamate a procedure di sistema o definite dall'utente tramite il costrutto \emph{deffunction}.


\subsubsection{Fatti}\label{par:linguaggio-fatti}

I \emph{fatti} costituiscono il contenuto della \emph{working memory}. Il linguaggio fornito deve prevedere, parallelamente a quanto previsto da CLIPS, la definizione dei fatti attraverso la notazione \emph{Ordered-Fact} e \emph{Template-Fact}.

\begin{program}
\verbatimtabinput[3]{Capitoli/capitolo-2/bnf/deffacts.txt}
\caption{Specifica \emph{BNF} del costrutto \emph{deffacts}}\label{code:deffacts}
\end{program}


La specifica dei fatti deve essere riunita all'interno di costrutti \emph{deffacts}~(Codice~\ref{code:deffacts}). Questo consente di inserire un elenco di definizioni che verranno automaticamente asserite durante la fase di inizializzazione del sistema esperto.

Il primo formato di specifica dei fatti, chiamato \emph{Ordered-Fact}, prevede la definizione degli stessi come vettori di elementi simbolici o numerici di lunghezza arbitraria. Il formato del primo elemento è richiesto che sia di tipo \emph{SYMBOL}\footnote{SYMBOL rappresenta un tipo elementare presente in CLIPS. Appartengono a questo tipo tutte le sequenze alfanumeriche non delimitate da apici e che abbiano come primo elemento un carattere alfabetico}, il formato dei successivi elementi è arbitrario.

La seconda modalità di specifica, denominata \emph{Template-Fact}, prevede la definizione dei fatti tramite l'utilizzo di un \emph{template} e una sequenza di \emph{slot}. Gli slot rappresentano delle caratteristiche definite nella specifica del \emph{template}.
La definizione del fatto può prevedere l'avvaloramento di tutti o solo una porzione degli \emph{slot} previsti dal \emph{template}.
I valori inseribili negli \emph{slot} possono essere singoli elementi o multipli. Nel secondo caso si farà riferimento allo \emph{slot} con il nome di \emph{multi-slot}.

\subsubsection{Template}\label{par:linguaggio-template}

La specifica dei fatti in formato \emph{Template-Fact} prevede la definizione preventiva di un \emph{template} che definisca una ''tipologia'' di fatti, indicata con un nome univoco e una sequenza di caratteristiche: \emph{slot} e \emph{multi-slot}~(Codice~\ref{code:deftemplate}).

\begin{program}
\verbatimtabinput[3]{Capitoli/capitolo-2/bnf/deftemplate.txt}
\caption{Specifica \emph{BNF} del costrutto  \emph{deftemplate}}\label{code:deftemplate}
\end{program}

La specifica prevede la definizione di valori di \emph{default}, da attribuire nei casi in cui non venga fornito un valore durante l'asserzione, oppure di restrizioni sul tipo di valori utilizzabili nello \emph{slot}.

\subsection{Parser}\label{par:parser}

Le funzionalità di analisi ed interpretazione dei costrutti specificati tramite il linguaggio di definizione sono racchiuse all'interno del \emph{parser}. Utilizzando una serie di regole sintattiche, questo componente è in grado di leggere le definizioni dei costrutti previsti dal linguaggio e convertirle in elementi computabili dal motore inferenziale.

Ad ogni costrutto definito dal linguaggio vengono associate una serie di regole sintattiche che descrivono i vincoli di validità e come convertire le varie definizioni, una volta individuate. Le regole vengono specificate attraverso l'alternanza di sequenze simboliche predefinite e campi variabili, che rappresentano le proprietà dei singoli costrutti.

Le regole vengono organizzate in strutture nidificate. Il riconoscimento di determinate sequenze simboliche relative ad una regola principale, spesso delimitate da parole chiave, attiva la possibilità di utilizzare sotto-regole associate a quella principale.

Il linguaggio di definizione prevede la possibilità di definire elementi in grado di alterare le regole sintattiche utilizzate dal \emph{parser}, come \emph{template} o \emph{funzioni}. Questo comporta la necessità di strutturare il processo di conversione come un'alternanza di fasi di analisi ed interpretazione, eseguite su singoli costrutti individualmente.

\subsection{Motore inferenziale}\label{par:motore-inferenziale}

Il motore inferenziale controlla il processo di ragionamento alla base di un sistema esperto. Il ragionamento è strutturato attraverso meccanismi di inferenza, che in questo sistema vengono esplicitati nella forma di regole di produzione.

L'utilizzo del motore inferenziale è regolato da quattro fasi:

\begin{enumerate}
	\item \emph{l'inizializzazione}, caricando conoscenza procedurale e fattuale. Il caricamento avviene attraverso la definizione di regole e gruppi di fatti iniziali. Le modalità con le quali gli elementi vengono specificati possono essere legate all'utilizzo del linguaggio di definizione o alla specifica diretta dei costrutti in una forma direttamente utilizzabile dal motore inferenziale. Nel primo caso sarà necessaria una fase di conversione delle definizioni, onere del parser.
	\item la \emph{preparazione}, nella quale il motore inferenziale organizza gli elementi ottenuti nella fase precedente all'interno di strutture specifiche che agevolino le elaborazioni successive. 
	%In questa fase l'insieme di regole viene trasformato nelle strutture utilizzate dall'algoritmo RETE per le operazioni di pattern-matching.
	\item l'\emph{esecuzione}, nella quale viene eseguito il ciclo \emph{recognize-act}.
	\item la \emph{valutazione}, una fase nella quale può essere analizzato lo stato finale nel quale ha avuto termine l'elaborazione.
\end{enumerate}

%Le fasi di preparazione ed esecuzione previste dal motore inferenziale garantiscono un utilizzo dello stesso
La realizzazione del ciclo di controllo \emph{recognize-act} prevede il confronto fra le condizioni espresse nelle porzioni \emph{LHS} delle regole e l'insieme di fatti memorizzato all'interno della memoria di lavoro. La verifica dell'applicabilità delle regole deve essere ripetuta come conseguenza di ogni modifica, anche minima, della memoria di lavoro. Per ridurre lo sforzo elaborativo richiesto dalle operazioni di confronto è possibile utilizzare l'algoritmo RETE~\cite{forgy1979}~\cite{forgy1982}~\cite{Doorenbos95productionmatching}.

\subsubsection{Algoritmo RETE}\label{par:algoritmo-rete}

\begin{figure}[h]
\centering
\includegraphics[scale=0.5, viewport=0 0 574 307]{Immagini/Capitolo2/Rete-blackbox.pdf}
\caption[RETE come una \emph{black-box}]{RETE come una \emph{black-box}: immagine originale tratta da \cite{Doorenbos95productionmatching}.}\label{fig:rete-black-box}
\end{figure}

L'algoritmo di \emph{pattern-matching} RETE consente un confronto efficiente fra il \emph{rules-set} e lo stato della \emph{working-memory}. Le attività svolte dall'algoritmo sono assimilabili a quelle di una \emph{black-box}~(\figurename~\ref{fig:rete-black-box}) alla quale vengono sottoposte due categorie di eventi: l'aggiunta o rimozione di regole e la modifica della \emph{working-memory}, intesa come asserzioni e ritrattazioni di fatti. Il risultato è in ogni caso un \emph{delta} delle attivazioni, un insieme di attivazioni da aggiungere o rimuovere dal \emph{conflict-set}~\cite{Doorenbos95productionmatching}.

Le attività legate alla modifica del \emph{rules-set} vengono normalmente svolte nelle fasi di preparazione del motore inferenziale, anche se questa assunzione non lede minimamente le possibilità di modifica del \emph{network} durante l'esecuzione. Le attività di valutazione delle modifiche alla \emph{working-memory} sono svolte sia nelle fasi di preparazione, valutando l'insieme di fatti iniziali, che di esecuzione, valutando asserzioni e ritrattazioni eseguite durante il ciclo \emph{recognize-act}.

\paragraph{Compilazione delle regole}

Il processo di \emph{compilazione} di una regola prevede la conversione dei \emph{pattern} presenti nella porzione \emph{LHS} delle regole in un grafo di valutazione. Ad ogni singolo \emph{pattern} deve essere fatto corrispondere un circuito che valuti le componenti statiche del pattern e che non richiedono un confronto con altri elementi della \emph{LHS}. Questo genere di confronti si definisce \emph{intra-element}. Le espressioni variabili vengono ignorate nell'esecuzione di questa classe di valutazioni.

I singoli circuiti vengono riuniti attraverso strutture che consentano di verificare la coerenza dei valori associati alle parti variabili, qualora queste ultime siano presenti in più di un \emph{pattern}. Questa classe di confronti viene definita \emph{inter-element}.

Il tipo di strutture che è possibile utilizzare durante il processo di conversione delle regole determina il tipo di confronti e operazioni che verranno effettuati durante fase di valutazione delle modifiche. Il processo di conversione può essere realizzato tramite la creazione di espressioni statiche, eseguite in sequenza per valutare le modifiche della \emph{working-memory}~\cite{forgy1979}~\cite{forgy1982} realizzando in questo modo una rappresentazione implicita di un grafo di valutazione. Questa forma di implementazione prende il nome di formulazione compilata. Una variante alternativa~\cite{Doorenbos95productionmatching} prevede la generazione esplicita del grafo attraverso la realizzazione di strutture che rappresentino i nodi, prendendo il nome di formulazione interpretata.

Il linguaggio di specifica~(Codice~\ref{code:defrule}) permette di esplicitare sia \emph{pattern} che verifichino l'esistenza diretta di fatti nella \emph{working-memory} (\texttt{Template\--Pattern\--CE}, \texttt{Ordered-Pattern-CE} e \texttt{Assigned-Pattern-CE}), che utilizzare connettivi logici per alterare il significato delle \emph{pattern}. I connettivi vengono esplicitati tramite \texttt{Not-CE} (negazione), \texttt{And-CE} (congiunzione), \texttt{Or-CE} (disgiunzione inclusiva). Queste condizioni possono essere valutate realizzando strutture apposite che eseguano i test tenendo conto del contesto offerto dal connettivo logico nel quale sono valutati. La formulazione proposta in \cite{Doorenbos95productionmatching} copre questi casi.
L'unica eccezione riguarda la disgiunzione inclusiva, la quale richiede invece una valutazione più approfondita per poter essere supportata dall'algoritmo~\cite{advacesrete}~\cite{Gordin:1991:SCR:115790.115797}.

\subparagraph{Compilazione di disgiunzioni inclusive}

La struttura della \emph{LHS} è implicitamente inclusa all'interno di un elemento condizionale \texttt{and} che verifichi la validità contemporanea di tutti i \emph{pattern}. La topologia dell'algoritmo RETE base~\cite{forgy1979}~\cite{forgy1982}~\cite{Doorenbos95productionmatching} però non consente la combinazione di elementi condizionali \texttt{and} e \texttt{or}. Per risolvere questo problema, garantendo l'utilizzo degli elementi \texttt{or-CE} nella specifica della \emph{LHS}, è possibile generare regole multiple per le quali sia garantita la conformità alla topologia di RETE da una singola regola contenente l'elemento \texttt{or}~\cite{clipsarch1992}. 
L'operazione di compilazione deve essere preceduta da tre fasi: trasformazione, riduzione e scomposizione.

\begin{figure}[h]
\centering
\begin{minipage}[t]{5.5cm}
\begin{lstlisting}[numbers=none]
(and
	(or <CE1> <CE2>)
	(or <CE3> <CE4>))
\end{lstlisting}
\end{minipage}
\ \hspace{2mm} \hspace{3mm} \
\begin{minipage}[t]{5.5cm}
\begin{lstlisting}[numbers=none]
(or	
	(or
		(and <CE1> <CE3>)
		(and <CE1> <CE4>))
	(or
		(and <CE2> <CE3>)
		(and <CE2> <CE4>)))
\end{lstlisting}
\end{minipage}
\caption[Applicazione delle proprietà dei connettivi logici]{Applicazione delle proprietà dei connettivi logici per eseguire una normalizzazione dei \emph{pattern}. A sinistra la forma iniziale, a destra quella convertita}\label{fig:esempio-normalizzazione}
\end{figure}

La fase di trasformazione consiste nello sfruttare le proprietà dei connettivi logici per eseguire una conversione dei \emph{pattern} della \emph{LHS}~(\figurename~\ref{fig:esempio-normalizzazione}) fino ad ottenere una forma normalizzata che assicuri l'eventuale presenza di elementi \texttt{or} solo come elementi radice o contenuti in ulteriori \texttt{or}.

\begin{figure}[h]
\centering
\begin{minipage}[t]{5.5cm}
\begin{lstlisting}[numbers=none]
(or	
	(or
		(and <CE1> <CE3>)
		(and <CE1> <CE4>))
	(or
		(and <CE2> <CE3>)
		(and <CE2> <CE4>)))
\end{lstlisting}
\end{minipage}
\ \hspace{2mm} \hspace{3mm} \
\begin{minipage}[t]{5.5cm}
\begin{lstlisting}[numbers=none]
(or	
	(and <CE1> <CE3>)
	(and <CE1> <CE4>)
	(and <CE2> <CE3>)
	(and <CE2> <CE4>))
\end{lstlisting}
\end{minipage}
\caption[Riduzione dei connettivi \texttt{or} adiacenti]{Riduzione dei connettivi \texttt{or} adiacenti. A sinistra la forma iniziale, a destra quella ridotta}\label{fig:esempio-riduzione}
\end{figure}


La fase di riduzione consente di eliminare connettivi logici ridondanti, riducendo connettivi \texttt{or} e \texttt{and} adiacenti~(\figurename~\ref{fig:esempio-riduzione}).

Come ultima fase, quella della scomposizione, i singoli \texttt{and-CE} contenuti all'interno della clausola \texttt{or} vengono scomposti come fossero regole differenti. Ad ognuna di esse verrà associato la medesima porzione \emph{RHS}. Le regole scomposte verranno collegate alla regola principale e rimosse contemporaneamente come fossero una singola istanza.


\paragraph{Valutazione delle modifiche}

Durante la fase di esecuzione del ciclo \emph{recognize-act} ha invece luogo la seconda attività prevista dall'algoritmo RETE: la valutazione delle modifiche della \emph{working-memory}. L'aggiunta o la rimozione di elementi dalla memoria di lavoro viene valutata tramite l'\emph{attraversamento} del grafo di valutazione generato nella fase di preparazione. Gli elementi \emph{WME} verranno riuniti durante l'attraverso della regione \emph{beta} di valutazione all'interno di strutture complesse, i \emph{Token}.
Le attivazioni parziali di pattern singoli vengono memorizzati in memorie locali poste come terminali della regione \emph{alpha}, realizzando una frontiera.
Le attivazioni parziali di sequenze di pattern vengono riunite nei \emph{Token} e stoccate in memorie locali poste come conseguente della struttura che ha eseguito \emph{Join} fra i pattern.
L'output offerto dalla valutazione, ottenuto dai nodi terminali, consiste nell'elenco di attivazioni da aggiungere o rimuovere dall'agenda delle attivazioni.

\subsubsection{Risoluzione dei conflitti}\label{par:strategie-crs}

La selezione dell'attivazione da eseguire viene effettuata utilizzando una serie di criteri. L'entità che racchiude questi criteri e li organizza prende il nome di \emph{strategia di risoluzione dei conflitti} (CRS)~\cite{McDermott:1977:PSC:1045343.1045364}. La CRS organizza l'elenco di attivazioni disponibili per ogni stato del sistema in base ad un ordinamento specifico. L'aggiunta o la rimozione di un fatto può determinare l'aggiornamento dell'intera sequenza. Per ogni iterazione del ciclo \emph{recognize-act} possono essere aggiunte o rimosse un numero arbitrario di attivazioni determinate dalla modifica allo stato del sistema eseguita nella fase \emph{act}. All'inizio di ogni ciclo, l'attivazione con priorità maggiore (sempre determinata in base ai criteri della CRS in uso) viene selezionata, rimossa dalla sequenza e quindi eseguita.

Il software deve fornire diverse strategie di risoluzione di conflitti:
\begin{description}
	\item[Depth:] ad attivazioni più recenti viene associata una priorità maggiore.
	
	\item[Breadth:] le nuove attivazioni vengono inserite nella sequenza con priorità inferiore a quelle già esistenti.
	
	\item[Simplicity:] viene utilizzato come criterio per determinarne la priorità un indice di generalità della regola~\cite{clipsarch1992}. A quelle con un minor grado di specializzazione verrà attribuita una priorità maggiore. Il coefficiente di complessità di ogni regola viene determinato prendendo in esame il numero di pattern presenti nella LHS, il numero di variabili utilizzate in ogni pattern ed il numero di connettivi ed espressioni logiche presenti. Il coefficiente, espresso tramite un valore numerico intero, viene quindi computato sommando le singoli componenti.
	
	\item[Complexity:] la specificità della regola a cui fa riferimento l'attivazione determina la priorità di attivazione~\cite{clipsarch1992}. Il coefficiente di complessità viene calcolato in maniera analoga a quanto fatto per la CRS \emph{Simplicity}, ma valori di complessità maggiori determineranno una maggiore priorità.
	\item[Lex:] la priorità di attivazione viene calcolata come segue~\cite{forgyops5manual}:
		\begin{itemize}
			\item ad ogni fatto viene attribuita un'etichetta temporale per determinare una relazione d'ordine.
			\item i fatti relativi ad ogni attivazione vengono quindi riordinati in modo decrescente.
			\item le attivazioni vengono confrontate prendendo in esame le sequenze ordinate di etichette temporali e assegnando priorità maggiore alle attivazioni con sequenze più recenti.
		\end{itemize}
	\item[Mea:] la priorità di attivazione viene calcolata come segue~\cite{forgyops5manual}:
		\begin{itemize}
			\item ad ogni fatto componente l'attivazione viene attribuita un'etichetta temporale per determinare una relazione d'ordine fra i fatti nella \emph{working-memory}.
			\item per ogni attivazione viene identificata l'etichetta temporale più recente
			\item le etichette vengono confrontate assegnando priorità maggiore all'attivazione con etichetta più recente.
		\end{itemize}
	\item[Random:] le attivazioni vengono ordinate in modo casuale.
\end{description}

Un ulteriore criterio discriminante comune a tutte le CRS è quello basato sulla valutazione della \emph{salience}. Ad ogni regola può essere associato un valore numerico intero per determinare esplicitamente una relazione d'ordine. Qualora questo valore non venga indicato durante la definizione, ne verrà attribuito uno di \emph{default}. La valutazione della \emph{salience} è il primo elemento discriminante per il computo della priorità. Per le attivazioni relative a regole con la stessa \emph{salience} viene utilizzata la strategia di risoluzione dei conflitti per effettuare l'ordinamento.

In aggiunta alle CRS fornite con il software, deve essere fornita la possibilità di integrare ulteriori strategie di risoluzione di conflitti.

\subsection{Terminale}\label{par:terminale}

Il terminale è la forma di utilizzo del sistema più immediata prevista. Permette ad un utente di inizializzare il motore inferenziale ed eseguire elaborazioni, rendendo il software un'applicazione a sé. 

Alla base del funzionamento del terminale ci sono le funzionalità offerte dal parser. L'utilizzo del linguaggio di definizione permette di caricare o definire i sistemi esperti o, più genericamente, impartire una sequenza di comandi al software.

Un comando non è altro che una funzione di sistema oppure una funzione utente definita attraverso il costrutto \emph{deffunction}. La chiamata di una procedura viene eseguita fornendo un nome univoco che rimandi alla funzione, la quale può essere accompagnata da un insieme di parametri che ne specifichino i dati di ingresso. Il numero ed il tipo dei parametri che è possibile fornire è definito dalla \emph{firma} della funzione. Questa è una struttura che definisce la funzione stessa indicando un nome univoco, il numero ed il tipo di parametri ammissibili come dati d'ingresso e il tipo dell'output fornito dalla funzione.

\subsection{Modulo Server}\label{par:server}

Il software deve essere accompagnato da un componente in grado di rendere fruibili le funzionalità offerte attraverso un modello di architettura distribuita \emph{client-server}.

Un sistema distribuito consiste di una collezione di componenti, suddivisi su diversi terminali (anche chiamati \emph{host}) connessi fra loro attraverso un canale di comunicazione. Questi componenti interagiscono fra loro al fine di scambiare dati od accedere reciprocamente a servizi disponibili~\cite{Mascolo:2002:MCM:770420.770423}.
La realizzazione di un sistema distribuito è soggetta alla predisposizione di un sistema di comunicazione fra i processi collocati nei vari \emph{host}.

\begin{figure}[h]
\centering
\includegraphics[scale=0.7, viewport=6 582 546 838]{Immagini/Capitolo2/Client-Server.pdf}
\caption[Architettura \emph{Client-Server}]{Architettura \emph{Client-Server}: in \emph{(a)} è mostrata una distribuzione su \emph{host} multipli, in \emph{(b)} una distribuzione in processi multipli}\label{fig:client-server}
\end{figure}

Il modello di architettura \emph{Client-Server} si basa sul partizionamento delle attività, risorse e responsabilità del sistema in due classi di componenti: \emph{Server} e \emph{Client}.
I componenti possono essere posizionati su \emph{host} fisicamente differenti, così come possono essere collocati in processi separati residenti sulla stessa macchina, in modo tale che non condividano direttamente risorse (\figurename~\ref{fig:client-server}). Lo scambio di informazioni avviene attraverso un protocollo noto ad entrambi i componenti.

Il modulo \emph{server} deve garantire la fruizione dei servizi offerti dall'\emph{en\-vi\-ron\-ment} a \emph{client} multipli contemporaneamente. \`E quindi necessario che i risultati intermedi di elaborazione, così le informazioni relative all'\emph{engine} e all'artefatto caricato, siano disponibili ed utilizzabili solo dal \emph{client} che ha eseguito il caricamento e le precedenti elaborazioni. Per supportare questo modello d'utilizzo, il \emph{server} deve essere in grado di associare un contesto univoco ad ogni richiesta che preveda l'utilizzo di risorse allocate in richieste precedenti.

L'inizializzazione del contesto deve essere richiesta dal \emph{client}: il \emph{server} provvederà all'allocazione delle risorse ed alla generazione di un identificativo di sessione univoco che verrà quindi fornito al \emph{client} e utilizzato dallo stesso per associare richieste successive al contesto inizializzato. Il server utilizza la sessione per memorizzare risultati parziali fra richieste successive, parametri di configurazione della comunicazione con il \emph{client} e, più genericamente, qualsiasi genere di informazione che possa essere ritenuta utile nel proseguo dell'elaborazione. Ogni sessione deve essere associata ad un tempo massimo di inattività oltre il quale la stessa venga rimossa automaticamente per consentire il recupero delle risorse allocate. Il tempo di inattività associato alla sessione deve essere calcolato tenendo presente l'ultima richiesta effettuata che abbia fornito l'identificativo come parametro di contesto. La rimozione della sessione può anche essere arbitrariamente richiesta dal \emph{client} che l'ha generata, nel momento in cui la stessa non sia ritenuta più necessaria.



%L'architettura \emph{Client-Server} descrive un modello di collaborazione fra sistemi. Il \emph{server} offre servizi o funzionalità a uno o più \emph{client}, mentre il \emph{client} effettua una richiesta e provvede ad elaborare i dati ottenuti come risposta dal \emph{server} per presentarli all'utente o proseguire con ulteriori elaborazioni.

%Lo stato della comunicazione fra \emph{client} e \emph{server} può essere di tipo volatile o persistente. Nel primo caso, il \emph{client} può utilizzare un servizio indicando semplicemente il nome della funzionalità e i parametri di elaborazione. La richiesta viene elaborata e i risultati restituiti. La connessione fra i componenti viene quindi chiusa. Nel secondo caso, l'utilizzo di una funzionalità deve essere preceduto dall'esecuzione di un preambolo, durante il quale venga inizializzata una sessione persistente fra \emph{client} e \emph{server}.
%La sessione viene archiviata e gestita dell'istanza \emph{server}: il componente farà uso della sessione per organizzare informazioni, risultati intermedi di elaborazioni   e risorse allocate relative ad un \emph{client}. Al \emph{client} invece, viene fornito un identificatore univoco di sessione che consentirà di relazionare ogni richiesta effettuata con un contesto di esecuzione univoco. La sessione viene archiviata per un tempo prefissato, oltre il quale viene distrutta. Ulteriore utilizzo di funzionalità sarà quindi nuovamente preceduto da un preambolo.

\section{Vincoli di sistema}
\vincoliinit
\subsection{Vincoli di interfaccia}

Si esplicitano i seguenti vincoli d'interfaccia.
\vincolistart
	\item Hardware\\	
	L'utente si interfaccia al sistema inserendo appositi comandi tramite tastiera. Inoltre acquisisce i risultati dell'elaborazione dei comandi attraverso il monitor. La tastiera viene inoltre utilizzata per l'inserimento di dati, qualora necessario.
	
	\item Utente\\
	L'interazione con il sistema avviene attraverso un'interfaccia testuale composta da una linea di comando, nella quale l'utente esplicita i comandi e attende i risultati dell'elaborazione. Anche i risultati vengono presentati nella medesima interfaccia testuale.
	
	\item Software\\
	L'utilizzo del sistema attraverso l'integrazione in applicazioni di terze parti prevede l'utilizzo di applicazioni per la scrittura di software o ambienti di sviluppo integrati (IDE).
	
	\item Software\\
	Il sistema prevede la possibilità di utilizzare applicazioni di \emph{text-editing} per la creazione dei sistemi esperti.
	
\vincoliend

\subsection{Vincoli operativi}

\vincolistart
	\item Hardware\\
	Per l'utilizzo in modalità \emph{Server}:
	\begin{itemize}
		\item 1GB di memoria RAM;
		\item Interfaccia di rete.
	\end{itemize}
	\item Software\\
	\`E previsto l'utilizzo del sistema su piattaforma PC con sistemi operativi
	\begin{itemize}
		\item Microsoft Windows XP, Vista, 7
		\item Ubuntu 12.04
	\end{itemize}
\vincoliend

\subsection{Vincoli prestazionali}
\vincolistart
	\item le prestazioni complessive del sistema devono permettere il completamento dei test di una \emph{benchmark-suite} in tempo ragionevole.
\vincoliend
\subsection{Vincoli di progetto}
\vincolistart
	\item il sistema deve permettere l'esecuzione di artefatti realizzati tramite CLIPS (escludendo quelli che utilizzano le estensioni del linguaggio COOL), richiedendo soltanto modifiche di lieve entità.
	
	\item il sistema deve prevedere la possibilità di integrare nuove funzionalità
\vincoliend

\subsection{Stabilità dei vincoli}

\begin{longtable}{|c|c|c|p{7cm}|}
\caption{Matrice di stabilità dei vincoli}\label{tab:stabilita-vincoli}\\
\hline\hline
\rowcolor{grigio-chiarissimo} \textbf{\#} & \textbf{Stabile} & \textbf{Instabile} & \textbf{Motivazione} \\
\hline\hline
\endfirsthead
\hline\hline
\rowcolor{grigio-chiarissimo} \textbf{\#} & \textbf{Stabile} & \textbf{Instabile} & \textbf{Motivazione} \\
\hline\hline
\endhead

Vincolo-1 &  & $\blacklozenge$ & Nuove tecnologie potrebbero far migrare il sistema verso nuove forme di interazione \\ 
\hline 
Vincolo-2 & $\blacklozenge$ &  &  \\ 
\hline 
Vincolo-3 & $\blacklozenge$ & & \\ 
\hline 
Vincolo-4 & $\blacklozenge$ & & \\ 
\hline 
Vincolo-5 &  & $\blacklozenge$ & Lo sviluppo tecnologico potrebbe portare a richieste hardware differenti come conseguenza di un ampliamento delle richieste software \\ 
\hline 
Vincolo-6 & $\blacklozenge$ & & \\ 
\hline 
Vincolo-7 & & $\blacklozenge$ & Lo sviluppo del sistema potrebbe portare all'introduzione di vincoli prestazionali \\ 
\hline 
Vincolo-8 & & $\blacklozenge$ & Lo sviluppo del sistema potrebbe portare all'ampliamento della compatibilità o a modifiche del linguaggio che riducano la portabilità degli artefatti\\ 
\hline 
Vincolo-9 & $\blacklozenge$ & & \\ 
\hline

\end{longtable}


\section{Attori e Casi d'uso}

\subsection{Attori}

In seguito ad un'analisi preliminare, sono state individuate sette classi di attori principali e relative relazioni di specializzazione (\figurename~\ref{fig:attori}).

\begin{figure}[h]
\centering
\includegraphics[width=0.9\textwidth]{Immagini/Capitolo2/UseCases/Attori.png}
\caption{Gerarchia degli attori}\label{fig:attori}
\end{figure}

\begin{description}
	\item[ES Consumer:] rappresenta un attore generalizzato in grado di utilizzare i servizi principali offerti dall'\emph{environment} per caricare, eseguire ed interagire con un artefatto precedentemente creato tramite i protocolli offerti dall'\emph{environment} stesso.
	
	\item[ES Developer:] servendosi del linguaggio di specifica fornito dall'\emph{environment} realizza artefatti eseguibili. Tramite l'utilizzo di apposite interfacce è anche in grado di testare l'artefatto prodotto analizzando rappresentazioni grafiche delle strutture interpretate e registri d'attività dell'esecuzione dell'artefatto.
	\item[Utente Umano]
	
	\item[Standalone Application:] utilizza i servizi offerti dall'\emph{environment} all'interno di applicazioni \emph{stand-alone}. Esegue artefatti e valuta i risultati dell'esecuzione analizzando eventi e lo stato finale del sistema.
	
	\item[Remote Application:] esegue attività analoghe a quelle di \emph{Standalone Application}, ma utilizzando i servizi tramite appositi protocolli di comunicazione. Per supportare questi protocolli l'attore può creare, configurare o distruggere sessioni.
	
	\item[Environment Developer:] utilizzando la documentazione di sistema e le apposite \emph{API} fornite, estende le funzionalità dell'\emph{environment} aggiungendo nuove funzioni di sistema, strategie di risoluzione dei conflitti o \emph{event-listener}. Utilizzando un framework per l'esecuzione di test d'unità, può verificare il funzionamento delle funzioni integrate.
	
	\item[Server Administrator:] configura e gestisce un'istanza server dell'\emph{en\-vi\-ron\-ment}.
	
\end{description}

\subsection{Organizzazione dei Casi d'uso}

\begin{figure}
\centering
\includegraphics[width=1.2\textwidth, angle=270]{Immagini/Capitolo2/UseCases/Vista-generale.png}
\caption{Vista generale dei casi d'uso principali}\label{fig:uc-vista-generale}
\end{figure}


I casi d'uso vengono organizzati in quattro gruppi  (\figurename~\ref{fig:uc-vista-generale}). Il gruppo di appartenenza di ognuno, indicato dal prefisso inserito nel nome, viene associato tenendo conto dell'attore principale al quale l'\emph{use case} fa riferimento. Il formato del nome di ogni caso d'uso seguirà quindi questa convenzione:
\begin{center}
UC[\emph{Attore}]-[\emph{Sezione}].[\emph{Gruppo}].[\emph{SottoGruppo}]: [\emph{Descrizione breve}]
\end{center}
dove:


\begin{description}
	\item[Attore] indica l'attore principale relazionato con il caso d'uso: \textbf{E} per \emph{Environment Developer}, \textbf{A} per \emph{Server Administrator}, \textbf{S} per \emph{Standalone Application}, \textbf{R} per \emph{Remote Application}, \textbf{D} per \emph{ES Developer} e \textbf{C} per \emph{ES Consumer}. Non è presente nessuno codice per l'attore \emph{Utente umano} in quanto non esiste alcun caso d'uso relativo esclusivamente ad esso.

	\item[Sezione] indica una delle sezioni principali presenti nella vista generale fornita in \figurename~\ref{fig:uc-vista-generale}.
	
	\item[Gruppo] e \textbf{SottoGruppo} esplicitano un'organizzazione gerarchica dei casi d'uso.

\end{description}

\pagebreak

\subsubsection{UCC-1: Utilizzo artefatto}

\input{Capitoli/capitolo-2/ucc-1}\pagebreak

\subsubsection{UCD-1: Creazione artefatto}

\input{Capitoli/capitolo-2/ucd-1}\pagebreak

\subsubsection{UCD-2: Testa artefatto}

\input{Capitoli/capitolo-2/ucd-2}\pagebreak

\subsubsection{UCE-1: Modifica funzioni di sistema}

\input{Capitoli/capitolo-2/uce-1}\pagebreak

\subsubsection{UCE-2: Monitorizza evento}

\input{Capitoli/capitolo-2/uce-2}\pagebreak

\subsubsection{UCE-3: Aggiunge CRS}

\input{Capitoli/capitolo-2/uce-3}\pagebreak

\subsubsection{UCE-4: Testa environment}

\input{Capitoli/capitolo-2/uce-4}\pagebreak

\subsubsection{UCA-1: Avvia Server}

\input{Capitoli/capitolo-2/uca-1}\pagebreak

\subsubsection{UCA-2: Arresta Server}

\input{Capitoli/capitolo-2/uca-2}\pagebreak

\subsubsection{UCA-3: Configura Server}

\input{Capitoli/capitolo-2/uca-3}\pagebreak

\subsubsection{UCS-1: Analisi dei risultati}

\input{Capitoli/capitolo-2/ucs-1}\pagebreak

\subsubsection{UCR-1: Inizializza sessione}

\input{Capitoli/capitolo-2/ucr-1}\pagebreak

\subsubsection{UCR-2: Distrugge sessione}

\input{Capitoli/capitolo-2/ucr-2}\pagebreak

\subsubsection{UCR-3: Richiede servizio}

\input{Capitoli/capitolo-2/ucr-3}\pagebreak


%\section{Requisiti}

%\subsection{Generale}

